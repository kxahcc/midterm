digraph "dateExpression" {  
"661" [label = <(METHOD,dateExpression)<SUB>639</SUB>> ]
"662" [label = <(PARAM,final String command)<SUB>639</SUB>> ]
"663" [label = <(PARAM,final String pattern)<SUB>639</SUB>> ]
"664" [label = <(BLOCK,&lt;empty&gt;,&lt;empty&gt;)<SUB>639</SUB>> ]
"665" [label = <(RETURN,return new Expression&lt;E&gt;() {\012\012    public Object evaluate(E exchange) {\012        Date date;\012        if (&quot;now&quot;.equals(command)) {\012            date = new Date();\012        } else if (command.startsWith(&quot;header.&quot;) || command.startsWith(&quot;in.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getIn().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else if (command.startsWith(&quot;out.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getOut().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else {\012            throw new IllegalArgumentException(&quot;Command not supported for dateExpression: &quot; + command);\012        }\012        SimpleDateFormat df = new SimpleDateFormat(pattern);\012        return df.format(date);\012    }\012\012    @Override\012    public String toString() {\012        return &quot;date(&quot; + command + &quot;:&quot; + pattern + &quot;)&quot;;\012    }\012};,return new Expression&lt;E&gt;() {\012\012    public Object evaluate(E exchange) {\012        Date date;\012        if (&quot;now&quot;.equals(command)) {\012            date = new Date();\012        } else if (command.startsWith(&quot;header.&quot;) || command.startsWith(&quot;in.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getIn().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else if (command.startsWith(&quot;out.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getOut().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else {\012            throw new IllegalArgumentException(&quot;Command not supported for dateExpression: &quot; + command);\012        }\012        SimpleDateFormat df = new SimpleDateFormat(pattern);\012        return df.format(date);\012    }\012\012    @Override\012    public String toString() {\012        return &quot;date(&quot; + command + &quot;:&quot; + pattern + &quot;)&quot;;\012    }\012};)<SUB>640</SUB>> ]
"666" [label = <(BLOCK,&lt;empty&gt;,&lt;empty&gt;)<SUB>640</SUB>> ]
"667" [label = <(&lt;operator&gt;.assignment,&lt;empty&gt;)> ]
"668" [label = <(IDENTIFIER,$obj37,&lt;empty&gt;)> ]
"669" [label = <(&lt;operator&gt;.alloc,new Expression&lt;E&gt;() {\012\012    public Object evaluate(E exchange) {\012        Date date;\012        if (&quot;now&quot;.equals(command)) {\012            date = new Date();\012        } else if (command.startsWith(&quot;header.&quot;) || command.startsWith(&quot;in.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getIn().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else if (command.startsWith(&quot;out.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getOut().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else {\012            throw new IllegalArgumentException(&quot;Command not supported for dateExpression: &quot; + command);\012        }\012        SimpleDateFormat df = new SimpleDateFormat(pattern);\012        return df.format(date);\012    }\012\012    @Override\012    public String toString() {\012        return &quot;date(&quot; + command + &quot;:&quot; + pattern + &quot;)&quot;;\012    }\012})<SUB>640</SUB>> ]
"670" [label = <(&lt;init&gt;,new Expression&lt;E&gt;() {\012\012    public Object evaluate(E exchange) {\012        Date date;\012        if (&quot;now&quot;.equals(command)) {\012            date = new Date();\012        } else if (command.startsWith(&quot;header.&quot;) || command.startsWith(&quot;in.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getIn().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else if (command.startsWith(&quot;out.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getOut().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else {\012            throw new IllegalArgumentException(&quot;Command not supported for dateExpression: &quot; + command);\012        }\012        SimpleDateFormat df = new SimpleDateFormat(pattern);\012        return df.format(date);\012    }\012\012    @Override\012    public String toString() {\012        return &quot;date(&quot; + command + &quot;:&quot; + pattern + &quot;)&quot;;\012    }\012})<SUB>640</SUB>> ]
"671" [label = <(IDENTIFIER,$obj37,new Expression&lt;E&gt;() {\012\012    public Object evaluate(E exchange) {\012        Date date;\012        if (&quot;now&quot;.equals(command)) {\012            date = new Date();\012        } else if (command.startsWith(&quot;header.&quot;) || command.startsWith(&quot;in.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getIn().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else if (command.startsWith(&quot;out.header.&quot;)) {\012            String key = command.substring(command.lastIndexOf(&quot;.&quot;) + 1);\012            date = exchange.getOut().getHeader(key, Date.class);\012            if (date == null) {\012                throw new IllegalArgumentException(&quot;Could not find java.util.Date object at &quot; + command);\012            }\012        } else {\012            throw new IllegalArgumentException(&quot;Command not supported for dateExpression: &quot; + command);\012        }\012        SimpleDateFormat df = new SimpleDateFormat(pattern);\012        return df.format(date);\012    }\012\012    @Override\012    public String toString() {\012        return &quot;date(&quot; + command + &quot;:&quot; + pattern + &quot;)&quot;;\012    }\012})> ]
"672" [label = <(IDENTIFIER,$obj37,&lt;empty&gt;)> ]
"673" [label = <(MODIFIER,PUBLIC)> ]
"674" [label = <(MODIFIER,STATIC)> ]
"675" [label = <(METHOD_RETURN,ANY)<SUB>639</SUB>> ]
  "661" -> "662" 
  "661" -> "663" 
  "661" -> "664" 
  "661" -> "673" 
  "661" -> "674" 
  "661" -> "675" 
  "664" -> "665" 
  "665" -> "666" 
  "666" -> "667" 
  "666" -> "670" 
  "666" -> "672" 
  "667" -> "668" 
  "667" -> "669" 
  "670" -> "671" 
}
